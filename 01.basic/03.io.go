package _1_basic

/*
高性能IO模型：为什么单线程Redis能那么快？

Redis 单线程
	Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程
	额外线程：Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的
	所以，严格来说，Redis 并不是单线程，但是我们一般把 Redis 称为单线程高性能，这样显得“酷”些

多线程的开销
	概述
		对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率
	如图 03.io_multithreaded.jpg
		左图是我们采用多线程时所期待的结果
		在采用多线程后，如果没有良好的系统设计，实际得到的结果，其实是右图所展示的那样
	为什么会出现这种情况呢？
		一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构
		当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证
		而这个额外的机制，就会带来额外的开销
	并发访问控制示例：多线程编程模式面临的共享资源的并发访问控制问题
		图示 03.io_redis_multithreaded.jpg
		Redis 有 List 的数据类型，并提供出队（LPOP）和入队（LPUSH）操作
		假设 Redis 采用多线程设计，如图所示，现在有两个线程 A 和 B，线程 A 对一个 List 做 LPUSH 操作，并对队列长度加 1
		同时，线程 B 对该 List 执行 LPOP 操作，并对队列长度减 1
		为了保证队列长度的正确性，Redis 需要让线程 A 和 B 的 LPUSH 和 LPOP 串行执行，这样一来，Redis 可以无误地记录它们对 List 长度的修改
		否则，我们可能就会得到错误的长度结果
Redis 为什么用单线程？
	并发访问控制一直是多线程开发中的一个难点问题
		只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：
		即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加
	而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性

单线程 Redis 为什么那么快？
	Redis 使用单线程模型却能达到每秒数十万级别的处理能力
	1.大部分操作在内存上完成
	2.它采用了高效的数据结构
	3.多路复用机制：使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率
基本 IO 模型与阻塞点
	基本流程示例：处理一个 Get 请求
		需要监听客户端请求（bind/listen）
		和客户端建立连接（accept）
		从 socket 中读取请求（recv）
		解析客户端发送请求（parse）
		根据请求类型读取键值数据（get）
		最后给客户端返回结果，即向 socket 中写回数据（send）
	图示 03.io_socket_model.jpg
		bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作
	潜在阻塞点
		accept()
			当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里
			导致其他客户端无法和 Redis 建立连接
		recv()
			当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()
非阻塞模式
	socket 网络模型本身支持非阻塞模式
	socket 类型：在 socket 模型中，不同操作调用后会返回不同的套接字类型
		socket() 方法会返回主动套接字
		然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求
		最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字
		图示 03.io_socket_type.jpg
	非阻塞模式
		针对监听套接字，可以设置非阻塞模式：
			当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待
			但是，你要注意的是，调用 accept() 时，已经存在监听套接字了
			虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis
		类似的，也可以针对已连接套接字设置非阻塞模式：
			Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作
			我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis
		这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据

基于多路复用的高性能 I/O 模型（天呐，我居然想到了这个处理的模型！！！）
	select/epoll 机制
		Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的select/epoll 机制
		在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字
		内核会一直监听这些套接字上的连接请求或数据请求
		一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果
	基于多路复用的 Redis 高性能 IO 模型
		图示
			03.io_select_epoll.jpg
			FD 就是多个套接字
		Redis 网络框架调用 epoll 机制，让内核监听这些套接字
		Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上
		正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性
	基于事件的回调机制
		为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制
		即针对不同事件的发生，调用相应的处理函数
	回调机制是怎么工作的呢？
		select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件
		这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理
		这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。
		同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调
		因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能
	举例
		两个请求分别对应 Accept 事件和 Read 事件
			Redis 分别对这两个事件注册 accept 和 get 回调函数
		当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件 和 Read 事件
		此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理
	比喻：就像病人去医院瞧病
		在医生实际诊断前，每个病人（等同于请求）都需要先分诊、测体温、登记等
		如果这些工作都由医生来完成，医生的工作效率就会很低
		所以，医院都设置了分诊台，分诊台会一直处理这些诊断前的工作（类似于 Linux 内核监听请求），然后再转交给医生做实际诊断
		这样即使一个医生（相当于 Redis 单线程），效率也能提升
	不同操作系统
		即使应用场景中部署了不同的操作系统，多路复用机制也是适用的，因为这个机制的实现有很多种
		既有基于 Linux 系统下的 select 和 epoll 实现
		也有基于 FreeBSD 的 kqueue 实现
		以及基于 Solaris 的 evport 实现
		这样，你可以根据 Redis 实际运行的操作系统，选择相应的多路复用实现

Redis 线程的三个问题小结：
	“Redis 真的只有单线程吗？”
		网络 IO 和数据读写的操作采用了一个线程
	“为什么用单线程？”
		一个核心原因是避免多线程开发的并发控制问题
	“单线程为什么这么快？”
		多路复用的 IO 模型，避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点

思考
	2020 年 5 月，Redis 6.0 的稳定版发布并提出了多线程模型
	那么，这个多线程模型和这里所说的 IO 模型有什么关联？会引入复杂的并发控制问题吗？会给 Redis 6.0 带来多大提升？
*/
